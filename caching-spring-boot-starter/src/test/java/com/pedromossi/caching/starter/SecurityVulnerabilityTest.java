package com.pedromossi.caching.starter;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.pedromossi.caching.CacheService;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.data.redis.serializer.GenericJackson2JsonRedisSerializer;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Security test to verify that the Redis deserialization vulnerability has been fixed.
 * This test demonstrates how the vulnerability could be exploited and verifies that
 * our secure configuration prevents such attacks.
 */
@SpringBootTest(
        classes = CachingAutoConfiguration.class,
        properties = {
                "caching.enabled=true",
                "caching.l1.enabled=false",
                "caching.l2.enabled=true",
                "caching.l2.ttl=PT30S"
        }
)
class SecurityVulnerabilityTest extends IntegrationTest {

    @Autowired
    private CacheService cacheService;

    /**
     * This test demonstrates the critical security vulnerability that we've fixed.
     * It shows how activateDefaultTyping could be exploited if it were still enabled.
     */
    @Test
    void demonstrateVulnerableConfiguration() {
        // Given: A vulnerable ObjectMapper with default typing enabled (DANGEROUS!)
        ObjectMapper vulnerableMapper = new ObjectMapper();
        vulnerableMapper.activateDefaultTyping(
                vulnerableMapper.getPolymorphicTypeValidator(),
                ObjectMapper.DefaultTyping.NON_FINAL
        );

        // And: A malicious payload with type information that could execute arbitrary code
        String maliciousJson = """
            {
              "@class": "java.util.HashMap",
              "data": "This could be exploited in a real attack"
            }
            """;

        // When/Then: The vulnerable mapper would deserialize to the specified class
        // This demonstrates the security risk we've mitigated
        try {
            Object result = vulnerableMapper.readValue(maliciousJson, Object.class);
            // In a real attack scenario, this could instantiate dangerous classes
            // like ProcessBuilder, URLClassLoader, etc. and execute arbitrary code
            assertThat(result).isInstanceOf(java.util.HashMap.class);
            assertThat(((java.util.HashMap<?, ?>) result).get("data")).isEqualTo("This could be exploited in a real attack");
        } catch (Exception e) {
            // This might throw an exception depending on the Jackson version and security settings
            assertThat(e).isNotNull();
        }
    }

    /**
     * Test that verifies our secure ObjectMapper configuration doesn't use default typing.
     * This test creates a serializer using our secure approach and verifies it doesn't
     * include dangerous type information.
     */
    @Test
    void shouldUseSecureObjectMapperConfiguration() {
        // Given: A secure ObjectMapper (like the one we use in our fixed configuration)
        ObjectMapper secureMapper = new ObjectMapper();
        // Note: We deliberately DO NOT call activateDefaultTyping here

        GenericJackson2JsonRedisSerializer secureSerializer = new GenericJackson2JsonRedisSerializer(secureMapper);

        // When: We serialize a test object
        SecurityVulnerabilityTest.TestObject testObj = new SecurityVulnerabilityTest.TestObject("secure_test", 42);
        byte[] serialized = secureSerializer.serialize(testObj);

        // Then: The serialized JSON should NOT contain @class type information
        String json = new String(serialized);
        assertThat(json).doesNotContain("@class");
        assertThat(json).contains("\"name\":\"secure_test\"");
        assertThat(json).contains("\"value\":42");
    }

    /**
     * Test that demonstrates the difference between vulnerable and secure serialization.
     */
    @Test
    void shouldShowDifferenceBetweenVulnerableAndSecureSerialization() {
        // Given: Both vulnerable and secure ObjectMappers
        ObjectMapper vulnerableMapper = new ObjectMapper();
        vulnerableMapper.activateDefaultTyping(
                vulnerableMapper.getPolymorphicTypeValidator(),
                ObjectMapper.DefaultTyping.NON_FINAL
        );

        ObjectMapper secureMapper = new ObjectMapper();
        // No activateDefaultTyping call for secure mapper

        TestObject testObj = new TestObject("comparison_test", 123);

        try {
            // When: We serialize the same object with both mappers directly
            String vulnerableJson = vulnerableMapper.writeValueAsString(testObj);
            String secureJson = secureMapper.writeValueAsString(testObj);

            // Then: The vulnerable version includes type information (dangerous format)
            // Note: GenericJackson2JsonRedisSerializer uses array format: [type, object]
            assertThat(vulnerableJson).contains("com.pedromossi.caching.starter.SecurityVulnerabilityTest$TestObject");

            // And: The secure version does NOT include type information (safe)
            assertThat(secureJson).doesNotContain("SecurityVulnerabilityTest");
            assertThat(secureJson).doesNotContain("TestObject");

            // Both should contain the actual data
            assertThat(vulnerableJson).contains("\"name\":\"comparison_test\"");
            assertThat(secureJson).contains("\"name\":\"comparison_test\"");
            assertThat(vulnerableJson).contains("\"value\":123");
            assertThat(secureJson).contains("\"value\":123");

        } catch (Exception e) {
            throw new RuntimeException("Failed to serialize test objects", e);
        }
    }

    /**
     * Test that demonstrates how malicious JSON with type information could be processed
     * differently by vulnerable vs secure configurations.
     */
    @Test
    void shouldHandleMaliciousJsonSafely() throws Exception {
        // Given: A malicious JSON payload using a class that Jackson can actually deserialize
        // We use java.util.HashSet as it's deserializable and demonstrates the vulnerability
        String maliciousPayloadArray = """
            ["java.util.HashMap", {"exploit": ["java.util.HashSet", ["malicious_value_1", "malicious_value_2"]]}]
            """;

        // And: A simpler malicious payload with @class format (for comparison)
        String maliciousPayloadClass = """
            {
              "@class": "java.util.HashMap",
              "exploit": {
                "@class": "java.util.HashSet", 
                "items": ["malicious_value_1", "malicious_value_2"]
              }
            }
            """;

        // And: Both vulnerable and secure ObjectMappers
        ObjectMapper vulnerableMapper = new ObjectMapper();
        vulnerableMapper.activateDefaultTyping(
                vulnerableMapper.getPolymorphicTypeValidator(),
                ObjectMapper.DefaultTyping.NON_FINAL
        );

        ObjectMapper secureMapper = new ObjectMapper();
        // No activateDefaultTyping - this is our fix

        // When/Then: Vulnerable mapper processes type directives in array format (dangerous)
        Object vulnerableResult = vulnerableMapper.readValue(maliciousPayloadArray, Object.class);
        assertThat(vulnerableResult).isInstanceOf(java.util.HashMap.class);

        // Verify that the vulnerable mapper actually instantiated the specified classes
        @SuppressWarnings("unchecked")
        java.util.Map<String, Object> vulnerableMap = (java.util.Map<String, Object>) vulnerableResult;
        assertThat(vulnerableMap.get("exploit")).isInstanceOf(java.util.HashSet.class);

        // And: Secure mapper treats the array as a regular JSON array (safe)
        Object secureResultArray = secureMapper.readValue(maliciousPayloadArray, Object.class);
        assertThat(secureResultArray).isInstanceOf(java.util.ArrayList.class);

        // Verify the secure mapper treats it as regular data
        @SuppressWarnings("unchecked")
        java.util.List<Object> secureArray = (java.util.List<Object>) secureResultArray;
        assertThat(secureArray.get(0)).isEqualTo("java.util.HashMap");
        assertThat(secureArray.get(1)).isInstanceOf(java.util.LinkedHashMap.class);

        // And: Secure mapper ignores @class directives (safe)
        Object secureResultClass = secureMapper.readValue(maliciousPayloadClass, Object.class);
        // Without default typing, @class is treated as a regular property
        assertThat(secureResultClass).isInstanceOf(java.util.LinkedHashMap.class);

        @SuppressWarnings("unchecked")
        java.util.Map<String, Object> secureMap = (java.util.Map<String, Object>) secureResultClass;
        assertThat(secureMap.get("@class")).isEqualTo("java.util.HashMap");
        assertThat(secureMap.get("exploit")).isInstanceOf(java.util.LinkedHashMap.class);
    }

    /**
     * Test that demonstrates a more realistic security vulnerability scenario.
     * This shows how an attacker could potentially exploit gadget chains in the classpath.
     */
    @Test
    void shouldPreventGadgetChainExploitation() throws Exception {
        // Given: A payload that tries to exploit using common Java classes
        // This simulates a real-world attack using available classes
        String gadgetPayload = """
            ["java.util.HashMap", {
                "data": ["java.util.ArrayList", ["item1", "item2", "item3"]],
                "metadata": ["java.util.TreeMap", {"key1": "value1", "key2": "value2"}]
            }]
            """;

        ObjectMapper vulnerableMapper = new ObjectMapper();
        vulnerableMapper.activateDefaultTyping(
                vulnerableMapper.getPolymorphicTypeValidator(),
                ObjectMapper.DefaultTyping.NON_FINAL
        );

        ObjectMapper secureMapper = new ObjectMapper();

        // When: Vulnerable mapper processes the payload
        Object vulnerableResult = vulnerableMapper.readValue(gadgetPayload, Object.class);

        // Then: Vulnerable mapper instantiates the specified classes (dangerous)
        assertThat(vulnerableResult).isInstanceOf(java.util.HashMap.class);
        @SuppressWarnings("unchecked")
        java.util.Map<String, Object> vulnerableMap = (java.util.Map<String, Object>) vulnerableResult;
        assertThat(vulnerableMap.get("data")).isInstanceOf(java.util.ArrayList.class);
        assertThat(vulnerableMap.get("metadata")).isInstanceOf(java.util.TreeMap.class);

        // When: Secure mapper processes the same payload
        Object secureResult = secureMapper.readValue(gadgetPayload, Object.class);

        // Then: Secure mapper treats it as regular data (safe)
        assertThat(secureResult).isInstanceOf(java.util.ArrayList.class);
        @SuppressWarnings("unchecked")
        java.util.List<Object> secureArray = (java.util.List<Object>) secureResult;
        assertThat(secureArray.get(0)).isEqualTo("java.util.HashMap");
        assertThat(secureArray.get(1)).isInstanceOf(java.util.LinkedHashMap.class);
    }

    /**
     * Test that verifies the CacheService is properly configured and working
     * (ensuring our security fix doesn't break functionality).
     */
    @Test
    void shouldVerifyCacheServiceIsConfigured() {
        // Then: CacheService should be properly autowired and configured
        assertThat(cacheService).isNotNull();
        // This confirms that our security fix doesn't break the overall configuration
    }

    /**
     * Test object for serialization tests.
     */
    public static class TestObject {
        private String name;
        private int value;

        public TestObject() {}

        public TestObject(String name, int value) {
            this.name = name;
            this.value = value;
        }

        // Getters and setters
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        public int getValue() { return value; }
        public void setValue(int value) { this.value = value; }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof TestObject)) return false;
            TestObject that = (TestObject) o;
            return value == that.value && java.util.Objects.equals(name, that.name);
        }

        @Override
        public int hashCode() {
            return java.util.Objects.hash(name, value);
        }
    }
}
